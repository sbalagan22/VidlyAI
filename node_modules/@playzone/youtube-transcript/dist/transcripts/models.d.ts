/**
 * Represents a single transcript snippet with timing information
 */
export declare class FetchedTranscriptSnippet {
    readonly text: string;
    readonly start: number;
    readonly duration: number;
    constructor(text: string, start: number, duration: number);
    /**
     * Convert to plain object for serialization
     */
    toRawData(): {
        text: string;
        start: number;
        duration: number;
    };
}
/**
 * Represents a fetched transcript containing multiple snippets
 */
export declare class FetchedTranscript {
    readonly snippets: FetchedTranscriptSnippet[];
    readonly videoId: string;
    readonly language: string;
    readonly languageCode: string;
    readonly isGenerated: boolean;
    constructor(snippets: FetchedTranscriptSnippet[], videoId: string, language: string, languageCode: string, isGenerated: boolean);
    /**
     * Get snippet at specific index
     */
    getSnippet(index: number): FetchedTranscriptSnippet | undefined;
    /**
     * Get total number of snippets
     */
    get length(): number;
    /**
     * Convert to plain object for serialization
     */
    toRawData(): Array<{
        text: string;
        start: number;
        duration: number;
    }>;
    /**
     * Iterator for snippets
     */
    [Symbol.iterator](): Iterator<FetchedTranscriptSnippet>;
}
/**
 * Represents a translation language option
 */
export declare class TranslationLanguage {
    readonly language: string;
    readonly languageCode: string;
    constructor(language: string, languageCode: string);
}
/**
 * Represents an individual transcript with metadata
 */
export declare class Transcript {
    readonly videoId: string;
    readonly language: string;
    readonly languageCode: string;
    readonly isGenerated: boolean;
    readonly translationLanguages: TranslationLanguage[];
    private readonly httpClient;
    private readonly url;
    private readonly translationLanguagesDict;
    constructor(httpClient: any, videoId: string, url: string, language: string, languageCode: string, isGenerated: boolean, translationLanguages: TranslationLanguage[]);
    /**
     * Check if this transcript can be translated
     */
    get isTranslatable(): boolean;
    /**
     * Fetch the actual transcript data
     */
    fetch(preserveFormatting?: boolean): Promise<FetchedTranscript>;
    /**
     * Translate this transcript to another language
     */
    translate(languageCode: string): Transcript;
    /**
     * Parse transcript XML data into snippets
     */
    private parseTranscript;
    /**
     * String representation
     */
    toString(): string;
}
/**
 * Represents a list of available transcripts for a video
 */
export declare class TranscriptList {
    readonly videoId: string;
    private readonly manuallyCreatedTranscripts;
    private readonly generatedTranscripts;
    private readonly translationLanguages;
    constructor(videoId: string, manuallyCreatedTranscripts: Map<string, Transcript>, generatedTranscripts: Map<string, Transcript>, translationLanguages: TranslationLanguage[]);
    /**
     * Find a transcript by language codes (prioritizes manually created)
     */
    findTranscript(languageCodes: string[]): Transcript;
    /**
     * Find only generated transcripts
     */
    findGeneratedTranscript(languageCodes: string[]): Transcript;
    /**
     * Find only manually created transcripts
     */
    findManuallyCreatedTranscript(languageCodes: string[]): Transcript;
    /**
     * Internal method to find transcript in specified sources
     */
    private findTranscriptInSources;
    /**
     * Get all transcripts as an array
     */
    getAllTranscripts(): Transcript[];
    /**
     * Iterator for all transcripts
     */
    [Symbol.iterator](): Iterator<Transcript>;
    /**
     * String representation
     */
    toString(): string;
}
//# sourceMappingURL=models.d.ts.map