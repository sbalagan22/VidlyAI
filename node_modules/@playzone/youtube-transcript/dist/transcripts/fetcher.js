"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptListFetcher = void 0;
const models_1 = require("./models");
const errors_1 = require("../errors");
/**
 * Constants for YouTube API
 */
const WATCH_URL = 'https://www.youtube.com/watch?v={videoId}';
const INNERTUBE_API_URL = 'https://www.youtube.com/youtubei/v1/player?key={apiKey}';
const INNERTUBE_CONTEXT = {
    client: {
        clientName: 'ANDROID',
        clientVersion: '20.10.38'
    }
};
/**
 * Playability status constants
 */
const PLAYABILITY_STATUS = {
    OK: 'OK',
    ERROR: 'ERROR',
    LOGIN_REQUIRED: 'LOGIN_REQUIRED'
};
/**
 * Playability failed reason constants
 */
const PLAYABILITY_FAILED_REASON = {
    BOT_DETECTED: "Sign in to confirm you're not a bot",
    AGE_RESTRICTED: 'This video may be inappropriate for some users.',
    VIDEO_UNAVAILABLE: 'This video is unavailable'
};
/**
 * Handles fetching transcript lists from YouTube
 */
class TranscriptListFetcher {
    constructor(httpClient, proxyConfig) {
        this.httpClient = httpClient;
        this.proxyConfig = proxyConfig;
    }
    /**
     * Fetch transcript list for a video
     */
    async fetch(videoId) {
        const captionsJson = await this.fetchCaptionsJson(videoId);
        return this.buildTranscriptList(videoId, captionsJson);
    }
    /**
     * Fetch captions JSON data from YouTube
     */
    async fetchCaptionsJson(videoId, tryNumber = 0) {
        try {
            const html = await this.fetchVideoHtml(videoId);
            const apiKey = this.extractInnertubeApiKey(html, videoId);
            const innertubeData = await this.fetchInnertubeData(videoId, apiKey);
            return this.extractCaptionsJson(innertubeData, videoId);
        }
        catch (error) {
            if (error instanceof errors_1.RequestBlocked) {
                const retries = this.proxyConfig?.retriesWhenBlocked || 0;
                if (tryNumber + 1 < retries) {
                    return this.fetchCaptionsJson(videoId, tryNumber + 1);
                }
                throw error.withProxyConfig(this.proxyConfig);
            }
            throw error;
        }
    }
    /**
     * Extract Innertube API key from HTML
     */
    extractInnertubeApiKey(html, videoId) {
        const pattern = /"INNERTUBE_API_KEY":\s*"([a-zA-Z0-9_-]+)"/;
        const match = html.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
        if (html.includes('class="g-recaptcha"')) {
            throw new errors_1.IpBlocked(videoId);
        }
        throw new errors_1.YouTubeDataUnparsable(videoId);
    }
    /**
     * Extract captions JSON from Innertube data
     */
    extractCaptionsJson(innertubeData, videoId) {
        this.assertPlayability(innertubeData.playabilityStatus, videoId);
        const captionsJson = innertubeData.captions?.playerCaptionsTracklistRenderer;
        if (!captionsJson || !captionsJson.captionTracks) {
            throw new errors_1.TranscriptsDisabled(videoId);
        }
        return captionsJson;
    }
    /**
     * Assert video playability status
     */
    assertPlayability(playabilityStatusData, videoId) {
        const playabilityStatus = playabilityStatusData?.status;
        if (playabilityStatus && playabilityStatus !== PLAYABILITY_STATUS.OK) {
            const reason = playabilityStatusData.reason;
            if (playabilityStatus === PLAYABILITY_STATUS.LOGIN_REQUIRED) {
                if (reason === PLAYABILITY_FAILED_REASON.BOT_DETECTED) {
                    throw new errors_1.RequestBlocked(videoId);
                }
                if (reason === PLAYABILITY_FAILED_REASON.AGE_RESTRICTED) {
                    throw new errors_1.AgeRestricted(videoId);
                }
            }
            if (playabilityStatus === PLAYABILITY_STATUS.ERROR &&
                reason === PLAYABILITY_FAILED_REASON.VIDEO_UNAVAILABLE) {
                if (videoId.startsWith('http://') || videoId.startsWith('https://')) {
                    throw new errors_1.InvalidVideoId(videoId);
                }
                throw new errors_1.VideoUnavailable(videoId);
            }
            const subreasons = playabilityStatusData.errorScreen?.playerErrorMessageRenderer?.subreason?.runs || [];
            const subreasonTexts = subreasons.map((run) => run.text || '').filter(Boolean);
            throw new errors_1.VideoUnplayable(videoId, reason, subreasonTexts);
        }
    }
    /**
     * Create consent cookie for GDPR compliance
     */
    createConsentCookie(html, videoId) {
        const match = html.match(/name="v" value="(.*?)"/);
        if (!match) {
            throw new errors_1.FailedToCreateConsentCookie(videoId);
        }
        // Set cookie in the HTTP client
        this.httpClient.defaults.headers.cookie = `CONSENT=YES+${match[1]}; Domain=.youtube.com`;
    }
    /**
     * Fetch video HTML page
     */
    async fetchVideoHtml(videoId) {
        let html = await this.fetchHtml(videoId);
        if (html.includes('action="https://consent.youtube.com/s"')) {
            this.createConsentCookie(html, videoId);
            html = await this.fetchHtml(videoId);
            if (html.includes('action="https://consent.youtube.com/s"')) {
                throw new errors_1.FailedToCreateConsentCookie(videoId);
            }
        }
        return html;
    }
    /**
     * Fetch HTML content
     */
    async fetchHtml(videoId) {
        const url = WATCH_URL.replace('{videoId}', videoId);
        const response = await this.httpClient.get(url);
        return this.unescapeHtml(response.data);
    }
    /**
     * Fetch Innertube API data
     */
    async fetchInnertubeData(videoId, apiKey) {
        const url = INNERTUBE_API_URL.replace('{apiKey}', apiKey);
        const response = await this.httpClient.post(url, {
            context: INNERTUBE_CONTEXT,
            videoId: videoId
        });
        return response.data;
    }
    /**
     * Build TranscriptList from captions JSON
     */
    buildTranscriptList(videoId, captionsJson) {
        const translationLanguages = (captionsJson.translationLanguages || []).map((tl) => new models_1.TranslationLanguage(tl.languageName.runs[0].text, tl.languageCode));
        const manuallyCreatedTranscripts = new Map();
        const generatedTranscripts = new Map();
        for (const caption of captionsJson.captionTracks) {
            const isGenerated = caption.kind === 'asr';
            const transcriptMap = isGenerated ? generatedTranscripts : manuallyCreatedTranscripts;
            const transcript = new models_1.Transcript(this.httpClient, videoId, caption.baseUrl.replace('&fmt=srv3', ''), caption.name.runs[0].text, caption.languageCode, isGenerated, caption.isTranslatable ? translationLanguages : []);
            transcriptMap.set(caption.languageCode, transcript);
        }
        return new models_1.TranscriptList(videoId, manuallyCreatedTranscripts, generatedTranscripts, translationLanguages);
    }
    /**
     * Unescape HTML entities
     */
    unescapeHtml(html) {
        return html
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .replace(/&nbsp;/g, ' ');
    }
}
exports.TranscriptListFetcher = TranscriptListFetcher;
//# sourceMappingURL=fetcher.js.map