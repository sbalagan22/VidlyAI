"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptList = exports.Transcript = exports.TranslationLanguage = exports.FetchedTranscript = exports.FetchedTranscriptSnippet = void 0;
const errors_1 = require("../errors");
/**
 * Represents a single transcript snippet with timing information
 */
class FetchedTranscriptSnippet {
    constructor(text, start, duration) {
        this.text = text;
        this.start = start;
        this.duration = duration;
    }
    /**
     * Convert to plain object for serialization
     */
    toRawData() {
        return {
            text: this.text,
            start: this.start,
            duration: this.duration
        };
    }
}
exports.FetchedTranscriptSnippet = FetchedTranscriptSnippet;
/**
 * Represents a fetched transcript containing multiple snippets
 */
class FetchedTranscript {
    constructor(snippets, videoId, language, languageCode, isGenerated) {
        this.snippets = snippets;
        this.videoId = videoId;
        this.language = language;
        this.languageCode = languageCode;
        this.isGenerated = isGenerated;
    }
    /**
     * Get snippet at specific index
     */
    getSnippet(index) {
        return this.snippets[index];
    }
    /**
     * Get total number of snippets
     */
    get length() {
        return this.snippets.length;
    }
    /**
     * Convert to plain object for serialization
     */
    toRawData() {
        return this.snippets.map(snippet => snippet.toRawData());
    }
    /**
     * Iterator for snippets
     */
    *[Symbol.iterator]() {
        for (const snippet of this.snippets) {
            yield snippet;
        }
    }
}
exports.FetchedTranscript = FetchedTranscript;
/**
 * Represents a translation language option
 */
class TranslationLanguage {
    constructor(language, languageCode) {
        this.language = language;
        this.languageCode = languageCode;
    }
}
exports.TranslationLanguage = TranslationLanguage;
/**
 * Represents an individual transcript with metadata
 */
class Transcript {
    constructor(httpClient, videoId, url, language, languageCode, isGenerated, translationLanguages) {
        this.httpClient = httpClient;
        this.videoId = videoId;
        this.url = url;
        this.language = language;
        this.languageCode = languageCode;
        this.isGenerated = isGenerated;
        this.translationLanguages = translationLanguages;
        this.translationLanguagesDict = new Map(translationLanguages.map(tl => [tl.languageCode, tl.language]));
    }
    /**
     * Check if this transcript can be translated
     */
    get isTranslatable() {
        return this.translationLanguages.length > 0;
    }
    /**
     * Fetch the actual transcript data
     */
    async fetch(preserveFormatting = false) {
        if (this.url.includes('&exp=xpe')) {
            throw new Error('PoTokenRequired'); // Will be replaced with proper error class
        }
        const response = await this.httpClient.get(this.url);
        const snippets = await this.parseTranscript(response.data, preserveFormatting);
        return new FetchedTranscript(snippets, this.videoId, this.language, this.languageCode, this.isGenerated);
    }
    /**
     * Translate this transcript to another language
     */
    translate(languageCode) {
        if (!this.isTranslatable) {
            throw new errors_1.NotTranslatable(this.videoId);
        }
        if (!this.translationLanguagesDict.has(languageCode)) {
            throw new errors_1.TranslationLanguageNotAvailable(this.videoId);
        }
        const translatedUrl = `${this.url}&tlang=${languageCode}`;
        const translatedLanguage = this.translationLanguagesDict.get(languageCode);
        return new Transcript(this.httpClient, this.videoId, translatedUrl, translatedLanguage, languageCode, true, // Translated transcripts are always generated
        [] // Translated transcripts can't be further translated
        );
    }
    /**
     * Parse transcript XML data into snippets
     */
    async parseTranscript(rawData, preserveFormatting) {
        const { parseTranscriptXml } = await Promise.resolve().then(() => __importStar(require('./parser')));
        return parseTranscriptXml(rawData, preserveFormatting);
    }
    /**
     * String representation
     */
    toString() {
        const translationDescription = this.isTranslatable ? '[TRANSLATABLE]' : '';
        return `${this.languageCode} ("${this.language}")${translationDescription}`;
    }
}
exports.Transcript = Transcript;
/**
 * Represents a list of available transcripts for a video
 */
class TranscriptList {
    constructor(videoId, manuallyCreatedTranscripts, generatedTranscripts, translationLanguages) {
        this.videoId = videoId;
        this.manuallyCreatedTranscripts = manuallyCreatedTranscripts;
        this.generatedTranscripts = generatedTranscripts;
        this.translationLanguages = translationLanguages;
    }
    /**
     * Find a transcript by language codes (prioritizes manually created)
     */
    findTranscript(languageCodes) {
        return this.findTranscriptInSources(languageCodes, [
            this.manuallyCreatedTranscripts,
            this.generatedTranscripts
        ]);
    }
    /**
     * Find only generated transcripts
     */
    findGeneratedTranscript(languageCodes) {
        return this.findTranscriptInSources(languageCodes, [this.generatedTranscripts]);
    }
    /**
     * Find only manually created transcripts
     */
    findManuallyCreatedTranscript(languageCodes) {
        return this.findTranscriptInSources(languageCodes, [this.manuallyCreatedTranscripts]);
    }
    /**
     * Internal method to find transcript in specified sources
     */
    findTranscriptInSources(languageCodes, transcriptSources) {
        for (const languageCode of languageCodes) {
            for (const transcriptSource of transcriptSources) {
                if (transcriptSource.has(languageCode)) {
                    return transcriptSource.get(languageCode);
                }
            }
        }
        throw new Error('NoTranscriptFound'); // Will be replaced with proper error class
    }
    /**
     * Get all transcripts as an array
     */
    getAllTranscripts() {
        return [
            ...this.manuallyCreatedTranscripts.values(),
            ...this.generatedTranscripts.values()
        ];
    }
    /**
     * Iterator for all transcripts
     */
    *[Symbol.iterator]() {
        for (const transcript of this.manuallyCreatedTranscripts.values()) {
            yield transcript;
        }
        for (const transcript of this.generatedTranscripts.values()) {
            yield transcript;
        }
    }
    /**
     * String representation
     */
    toString() {
        const manuallyCreated = Array.from(this.manuallyCreatedTranscripts.values())
            .map(t => ` - ${t.toString()}`)
            .join('\n');
        const generated = Array.from(this.generatedTranscripts.values())
            .map(t => ` - ${t.toString()}`)
            .join('\n');
        const translations = this.translationLanguages
            .map(tl => ` - ${tl.languageCode} ("${tl.language}")`)
            .join('\n');
        return `For this video (${this.videoId}) transcripts are available in the following languages:\n\n` +
            `(MANUALLY CREATED)\n${manuallyCreated || 'None'}\n\n` +
            `(GENERATED)\n${generated || 'None'}\n\n` +
            `(TRANSLATION LANGUAGES)\n${translations || 'None'}`;
    }
}
exports.TranscriptList = TranscriptList;
//# sourceMappingURL=models.js.map