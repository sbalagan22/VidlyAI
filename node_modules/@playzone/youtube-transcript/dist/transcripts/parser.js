"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TranscriptParser = void 0;
exports.parseTranscriptXml = parseTranscriptXml;
const xml2js_1 = require("xml2js");
const models_1 = require("./models");
/**
 * HTML formatting tags that can be preserved
 */
const FORMATTING_TAGS = [
    'strong', // important
    'em', // emphasized
    'b', // bold
    'i', // italic
    'mark', // marked
    'small', // smaller
    'del', // deleted
    'ins', // inserted
    'sub', // subscript
    'sup', // superscript
];
/**
 * Parser for YouTube transcript XML data
 */
class TranscriptParser {
    constructor(preserveFormatting = false) {
        this.preserveFormatting = preserveFormatting;
        this.htmlRegex = this.getHtmlRegex(preserveFormatting);
    }
    /**
     * Parse raw transcript XML data into snippets
     */
    async parse(rawData) {
        try {
            const xmlDoc = await this.parseXml(rawData);
            const snippets = [];
            if (xmlDoc && xmlDoc.transcript && xmlDoc.transcript.text) {
                for (const element of xmlDoc.transcript.text) {
                    if (element._) {
                        const text = this.cleanText(element._);
                        const start = parseFloat(element.$.start || '0');
                        const duration = parseFloat(element.$.dur || '0');
                        snippets.push(new models_1.FetchedTranscriptSnippet(text, start, duration));
                    }
                }
            }
            return snippets;
        }
        catch (error) {
            throw new Error(`Failed to parse transcript XML: ${error}`);
        }
    }
    /**
     * Parse XML string into object
     */
    parseXml(xmlString) {
        return new Promise((resolve, reject) => {
            (0, xml2js_1.parseString)(xmlString, { explicitArray: false }, (err, result) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(result);
                }
            });
        });
    }
    /**
     * Clean text by removing unwanted HTML tags
     */
    cleanText(text) {
        return text.replace(this.htmlRegex, '').trim();
    }
    /**
     * Get HTML regex based on formatting preservation setting
     */
    getHtmlRegex(preserveFormatting) {
        if (preserveFormatting) {
            const formatsRegex = FORMATTING_TAGS.join('|');
            const pattern = `</?(?!/?(${formatsRegex})\\b).*?\\b>`;
            return new RegExp(pattern, 'gi');
        }
        else {
            return /<[^>]*>/gi;
        }
    }
}
exports.TranscriptParser = TranscriptParser;
/**
 * Utility function to parse transcript XML
 */
async function parseTranscriptXml(rawData, preserveFormatting = false) {
    const parser = new TranscriptParser(preserveFormatting);
    return parser.parse(rawData);
}
//# sourceMappingURL=parser.js.map