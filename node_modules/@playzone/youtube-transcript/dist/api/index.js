"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTubeTranscriptApi = void 0;
exports.createYouTubeTranscriptApi = createYouTubeTranscriptApi;
const axios_1 = __importDefault(require("axios"));
const fetcher_1 = require("../transcripts/fetcher");
/**
 * Main YouTube Transcript API class
 */
class YouTubeTranscriptApi {
    constructor(proxyConfig, httpClient) {
        const client = httpClient || this.createHttpClient(proxyConfig);
        this.fetcher = new fetcher_1.TranscriptListFetcher(client, proxyConfig);
    }
    /**
     * Create HTTP client with proper configuration
     */
    createHttpClient(proxyConfig) {
        const client = axios_1.default.create({
            timeout: 10000,
            headers: {
                'Accept-Language': 'en-US',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
        });
        if (proxyConfig) {
            const proxyConfigDict = proxyConfig.toRequestsConfig();
            // Configure proxy
            client.defaults.proxy = false; // Disable axios proxy handling
            // Add proxy configuration to request interceptor
            client.interceptors.request.use((config) => {
                if (proxyConfigDict.http || proxyConfigDict.https) {
                    const proxyUrl = proxyConfigDict.https || proxyConfigDict.http;
                    const auth = this.extractProxyAuth(proxyUrl);
                    config.proxy = {
                        protocol: 'http',
                        host: this.extractProxyHost(proxyUrl),
                        port: this.extractProxyPort(proxyUrl),
                        ...(auth && { auth })
                    };
                }
                return config;
            });
            // Prevent keeping connections alive for rotating proxies
            if (proxyConfig.preventKeepingConnectionsAlive) {
                client.defaults.headers.common['Connection'] = 'close';
            }
        }
        return client;
    }
    /**
     * Extract proxy host from URL
     */
    extractProxyHost(url) {
        try {
            const urlObj = new URL(url);
            return urlObj.hostname;
        }
        catch {
            return 'localhost';
        }
    }
    /**
     * Extract proxy port from URL
     */
    extractProxyPort(url) {
        try {
            const urlObj = new URL(url);
            return parseInt(urlObj.port) || 80;
        }
        catch {
            return 80;
        }
    }
    /**
     * Extract proxy authentication from URL
     */
    extractProxyAuth(url) {
        try {
            const urlObj = new URL(url);
            if (urlObj.username && urlObj.password) {
                return {
                    username: urlObj.username,
                    password: urlObj.password
                };
            }
        }
        catch {
            // Ignore parsing errors
        }
        return undefined;
    }
    /**
     * Fetch transcript for a single video (shortcut method)
     */
    async fetch(videoId, languages = ['en'], preserveFormatting = false) {
        const transcriptList = await this.list(videoId);
        const transcript = transcriptList.findTranscript(languages);
        return transcript.fetch(preserveFormatting);
    }
    /**
     * Get list of available transcripts for a video
     */
    async list(videoId) {
        return this.fetcher.fetch(videoId);
    }
}
exports.YouTubeTranscriptApi = YouTubeTranscriptApi;
/**
 * Convenience function to create a new API instance
 */
function createYouTubeTranscriptApi(proxyConfig, httpClient) {
    return new YouTubeTranscriptApi(proxyConfig, httpClient);
}
/**
 * Default export
 */
exports.default = YouTubeTranscriptApi;
//# sourceMappingURL=index.js.map