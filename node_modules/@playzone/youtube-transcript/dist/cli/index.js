"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTubeTranscriptCli = void 0;
exports.main = main;
const commander_1 = require("commander");
const api_1 = require("../api");
const proxies_1 = require("../proxies");
const formatters_1 = require("../formatters");
const models_1 = require("../transcripts/models");
/**
 * CLI class for YouTube Transcript API
 */
class YouTubeTranscriptCli {
    constructor() {
        this.program = new commander_1.Command();
        this.setupCommands();
    }
    /**
     * Setup CLI commands and options
     */
    setupCommands() {
        this.program
            .name('youtube-transcript-api')
            .description('This is a JavaScript API which allows you to get the transcripts/subtitles for a given YouTube video. ' +
            'It also works for automatically generated subtitles and it does not require a headless browser, ' +
            'like other selenium based solutions do!')
            .version('1.0.0')
            .argument('[video-ids...]', 'List of YouTube video IDs')
            .option('--list-transcripts', 'This will list the languages in which the given videos are available in.')
            .option('--languages <languages...>', 'A list of language codes in a descending priority. For example, if this is set to "de en" it will ' +
            'first try to fetch the german transcript (de) and then fetch the english transcript (en) if it fails ' +
            'to do so. As I can\'t provide a complete list of all working language codes with full certainty, you ' +
            'may have to play around with the language codes a bit, to find the one which is working for you!', ['en'])
            .option('--exclude-generated', 'If this flag is set transcripts which have been generated by YouTube will not be retrieved.')
            .option('--exclude-manually-created', 'If this flag is set transcripts which have been manually created will not be retrieved.')
            .option('--format <format>', 'Output format for transcripts', 'pretty')
            .option('--translate <language>', 'The language code for the language you want this transcript to be translated to. Use the ' +
            '--list-transcripts feature to find out which languages are translatable and which translation ' +
            'languages are available.')
            .option('--webshare-proxy-username <username>', 'Specify your Webshare "Proxy Username" found at https://dashboard.webshare.io/proxy/settings')
            .option('--webshare-proxy-password <password>', 'Specify your Webshare "Proxy Password" found at https://dashboard.webshare.io/proxy/settings')
            .option('--http-proxy <url>', 'Use the specified HTTP proxy.')
            .option('--https-proxy <url>', 'Use the specified HTTPS proxy.')
            .action(this.handleCommand.bind(this));
    }
    /**
     * Handle the main command
     */
    async handleCommand(videoIds, options) {
        try {
            // Commander.js passes arguments differently - check if videoIds is actually the options
            if (Array.isArray(videoIds) && videoIds.length > 0 && typeof videoIds[0] === 'string' && !videoIds[0].startsWith('--')) {
                // videoIds is correctly passed
            }
            else if (options && Array.isArray(options.videoIds)) {
                // Arguments might be in options
                videoIds = options.videoIds;
            }
            else {
                // Try to get from process.argv
                const args = process.argv.slice(2);
                const videoIdArgs = args.filter(arg => !arg.startsWith('--'));
                if (videoIdArgs.length > 0) {
                    videoIds = videoIdArgs;
                }
            }
            if (!videoIds || videoIds.length === 0) {
                this.program.help();
                return;
            }
            if (options.excludeManuallyCreated && options.excludeGenerated) {
                console.log('');
                return;
            }
            const proxyConfig = this.createProxyConfig(options);
            const api = new api_1.YouTubeTranscriptApi(proxyConfig);
            const results = [];
            const errors = [];
            for (const videoId of videoIds) {
                try {
                    if (options.listTranscripts) {
                        const transcriptList = await api.list(videoId);
                        results.push(transcriptList);
                    }
                    else {
                        const transcript = await this.fetchTranscript(api, videoId, options);
                        results.push(transcript);
                    }
                }
                catch (error) {
                    errors.push(error);
                }
            }
            this.printResults(results, errors, options);
        }
        catch (error) {
            console.error('Error:', error);
            process.exit(1);
        }
    }
    /**
     * Create proxy configuration from options
     */
    createProxyConfig(options) {
        if (options.webshareProxyUsername || options.webshareProxyPassword) {
            return new proxies_1.WebshareProxyConfig(options.webshareProxyUsername || '', options.webshareProxyPassword || '');
        }
        if (options.httpProxy || options.httpsProxy) {
            return new proxies_1.GenericProxyConfig(options.httpProxy, options.httpsProxy);
        }
        return undefined;
    }
    /**
     * Fetch transcript based on options
     */
    async fetchTranscript(api, videoId, options) {
        const transcriptList = await api.list(videoId);
        let transcript;
        if (options.excludeManuallyCreated) {
            transcript = transcriptList.findGeneratedTranscript(options.languages);
        }
        else if (options.excludeGenerated) {
            transcript = transcriptList.findManuallyCreatedTranscript(options.languages);
        }
        else {
            transcript = transcriptList.findTranscript(options.languages);
        }
        if (options.translate) {
            transcript = transcript.translate(options.translate);
        }
        return transcript.fetch();
    }
    /**
     * Print results to console
     */
    printResults(results, errors, options) {
        const outputSections = [];
        // Add error messages
        for (const error of errors) {
            outputSections.push(error.message);
        }
        // Add results
        if (results.length > 0) {
            if (options.listTranscripts) {
                for (const result of results) {
                    if (result instanceof models_1.TranscriptList) {
                        outputSections.push(result.toString());
                    }
                }
            }
            else {
                const transcripts = results.filter(r => r instanceof models_1.FetchedTranscript);
                if (transcripts.length > 0) {
                    const formatter = new formatters_1.FormatterLoader().load(options.format);
                    outputSections.push(formatter.formatTranscripts(transcripts));
                }
            }
        }
        console.log(outputSections.join('\n\n'));
    }
    /**
     * Run the CLI
     */
    run(args) {
        this.program.parse(args);
    }
}
exports.YouTubeTranscriptCli = YouTubeTranscriptCli;
/**
 * Main CLI entry point
 */
function main() {
    const cli = new YouTubeTranscriptCli();
    cli.run(process.argv.slice(2));
}
// Run if called directly
if (require.main === module) {
    main();
}
//# sourceMappingURL=index.js.map