"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatterLoader = exports.WebVTTFormatter = exports.SRTFormatter = exports.TextBasedFormatter = exports.TextFormatter = exports.JSONFormatter = exports.PrettyPrintFormatter = exports.Formatter = void 0;
/**
 * Base formatter class
 */
class Formatter {
}
exports.Formatter = Formatter;
/**
 * Pretty print formatter
 */
class PrettyPrintFormatter extends Formatter {
    formatTranscript(transcript, options = {}) {
        return JSON.stringify(transcript.toRawData(), null, 2);
    }
    formatTranscripts(transcripts, options = {}) {
        return JSON.stringify(transcripts.map(t => t.toRawData()), null, 2);
    }
}
exports.PrettyPrintFormatter = PrettyPrintFormatter;
/**
 * JSON formatter
 */
class JSONFormatter extends Formatter {
    formatTranscript(transcript, options = {}) {
        return JSON.stringify(transcript.toRawData(), null, options.indent || 0);
    }
    formatTranscripts(transcripts, options = {}) {
        return JSON.stringify(transcripts.map(t => t.toRawData()), null, options.indent || 0);
    }
}
exports.JSONFormatter = JSONFormatter;
/**
 * Plain text formatter
 */
class TextFormatter extends Formatter {
    formatTranscript(transcript, options = {}) {
        return transcript.snippets.map(snippet => snippet.text).join('\n');
    }
    formatTranscripts(transcripts, options = {}) {
        return transcripts
            .map(transcript => this.formatTranscript(transcript, options))
            .join('\n\n\n');
    }
}
exports.TextFormatter = TextFormatter;
/**
 * Base class for text-based formatters with timestamps
 */
class TextBasedFormatter extends TextFormatter {
    /**
     * Convert seconds to timestamp
     */
    secondsToTimestamp(time) {
        const hours = Math.floor(time / 3600);
        const remainder = time % 3600;
        const mins = Math.floor(remainder / 60);
        const secs = Math.floor(remainder % 60);
        const ms = Math.round((time - Math.floor(time)) * 1000);
        return this.formatTimestamp(hours, mins, secs, ms);
    }
    formatTranscript(transcript, options = {}) {
        const lines = [];
        for (let i = 0; i < transcript.snippets.length; i++) {
            const snippet = transcript.snippets[i];
            if (!snippet)
                continue;
            const end = snippet.start + snippet.duration;
            // Use next snippet's start time if available and earlier than calculated end
            let endTime = end;
            if (i < transcript.snippets.length - 1) {
                const nextSnippet = transcript.snippets[i + 1];
                if (nextSnippet && nextSnippet.start < end) {
                    endTime = nextSnippet.start;
                }
            }
            const timeText = `${this.secondsToTimestamp(snippet.start)} --> ${this.secondsToTimestamp(endTime)}`;
            lines.push(this.formatTranscriptLine(i, timeText, snippet));
        }
        return this.formatTranscriptHeader(lines);
    }
}
exports.TextBasedFormatter = TextBasedFormatter;
/**
 * SRT formatter
 */
class SRTFormatter extends TextBasedFormatter {
    formatTimestamp(hours, mins, secs, ms) {
        return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
    }
    formatTranscriptHeader(lines) {
        return lines.join('\n\n') + '\n';
    }
    formatTranscriptLine(index, timeText, snippet) {
        return `${index + 1}\n${timeText}\n${snippet.text}`;
    }
}
exports.SRTFormatter = SRTFormatter;
/**
 * WebVTT formatter
 */
class WebVTTFormatter extends TextBasedFormatter {
    formatTimestamp(hours, mins, secs, ms) {
        return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }
    formatTranscriptHeader(lines) {
        return 'WEBVTT\n\n' + lines.join('\n\n') + '\n';
    }
    formatTranscriptLine(index, timeText, snippet) {
        return `${timeText}\n${snippet.text}`;
    }
}
exports.WebVTTFormatter = WebVTTFormatter;
/**
 * Formatter loader
 */
class FormatterLoader {
    /**
     * Load formatter by type
     */
    load(formatterType = 'pretty') {
        if (!(formatterType in FormatterLoader.TYPES)) {
            const supportedTypes = Object.keys(FormatterLoader.TYPES).join(', ');
            throw new Error(`The format '${formatterType}' is not supported. ` +
                `Choose one of the following formats: ${supportedTypes}`);
        }
        const FormatterClass = FormatterLoader.TYPES[formatterType];
        if (!FormatterClass) {
            throw new Error(`Formatter class not found for type: ${formatterType}`);
        }
        return new FormatterClass();
    }
    /**
     * Get all supported formatter types
     */
    static getSupportedTypes() {
        return Object.keys(FormatterLoader.TYPES);
    }
}
exports.FormatterLoader = FormatterLoader;
FormatterLoader.TYPES = {
    json: JSONFormatter,
    pretty: PrettyPrintFormatter,
    text: TextFormatter,
    webvtt: WebVTTFormatter,
    srt: SRTFormatter,
};
//# sourceMappingURL=index.js.map