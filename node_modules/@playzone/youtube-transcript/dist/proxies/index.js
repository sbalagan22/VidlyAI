"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebshareProxyConfig = exports.EnhancedProxyConfig = exports.GenericProxyConfig = exports.InvalidProxyConfig = exports.ProxyConfig = void 0;
/**
 * Base class for all proxy configurations
 */
class ProxyConfig {
    /**
     * Whether to prevent keeping connections alive (useful for rotating proxies)
     */
    get preventKeepingConnectionsAlive() {
        return false;
    }
    /**
     * Number of retries when blocked
     */
    get retriesWhenBlocked() {
        return 0;
    }
}
exports.ProxyConfig = ProxyConfig;
/**
 * Exception for invalid proxy configurations
 */
class InvalidProxyConfig extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidProxyConfig';
    }
}
exports.InvalidProxyConfig = InvalidProxyConfig;
/**
 * Generic proxy configuration for HTTP/HTTPS/SOCKS proxies
 */
class GenericProxyConfig extends ProxyConfig {
    constructor(httpUrl, httpsUrl) {
        super();
        if (!httpUrl && !httpsUrl) {
            throw new InvalidProxyConfig('GenericProxyConfig requires you to define at least one of the two: http or https');
        }
        this.httpUrl = httpUrl;
        this.httpsUrl = httpsUrl;
    }
    toRequestsConfig() {
        const httpUrl = this.httpUrl || this.httpsUrl;
        const httpsUrl = this.httpsUrl || this.httpUrl;
        return {
            http: httpUrl,
            https: httpsUrl
        };
    }
}
exports.GenericProxyConfig = GenericProxyConfig;
/**
 * Enhanced proxy configuration using http-proxy-agent and https-proxy-agent
 */
class EnhancedProxyConfig extends ProxyConfig {
    constructor(options) {
        super();
        if (options.enabled && !options.http && !options.https) {
            throw new InvalidProxyConfig('EnhancedProxyConfig requires at least one of http or https URLs when enabled');
        }
        this.options = options;
    }
    toRequestsConfig() {
        if (!this.options.enabled) {
            return {};
        }
        return {
            http: this.options.http || undefined,
            https: this.options.https || this.options.http || undefined
        };
    }
    get preventKeepingConnectionsAlive() {
        return this.options.enabled;
    }
    get retriesWhenBlocked() {
        return 0;
    }
}
exports.EnhancedProxyConfig = EnhancedProxyConfig;
/**
 * Webshare proxy configuration for rotating residential proxies
 */
class WebshareProxyConfig extends ProxyConfig {
    constructor(proxyUsername, proxyPassword, filterIpLocations = [], retriesWhenBlocked = 10, domainName = WebshareProxyConfig.DEFAULT_DOMAIN_NAME, proxyPort = WebshareProxyConfig.DEFAULT_PORT) {
        super();
        this.proxyUsername = proxyUsername;
        this.proxyPassword = proxyPassword;
        this.domainName = domainName;
        this.proxyPort = proxyPort;
        this.filterIpLocations = filterIpLocations;
        this._retriesWhenBlocked = retriesWhenBlocked;
    }
    get url() {
        const locationCodes = this.filterIpLocations
            .map(location => `-${location.toUpperCase()}`)
            .join('');
        return `http://${this.proxyUsername}${locationCodes}-rotate:${this.proxyPassword}@${this.domainName}:${this.proxyPort}/`;
    }
    toRequestsConfig() {
        return {
            http: this.url,
            https: this.url
        };
    }
    get preventKeepingConnectionsAlive() {
        return true;
    }
    get retriesWhenBlocked() {
        return this._retriesWhenBlocked;
    }
}
exports.WebshareProxyConfig = WebshareProxyConfig;
WebshareProxyConfig.DEFAULT_DOMAIN_NAME = 'p.webshare.io';
WebshareProxyConfig.DEFAULT_PORT = 80;
//# sourceMappingURL=index.js.map